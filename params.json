{
  "name": "Vim Script 101",
  "tagline": "",
  "body": "\r\nI'm currently working on [a plugin for vim](https://github.com/averagehat/phonim-jython). Along the way I've discovered a lot of intersting and useful productivity tricks. \r\n\r\n###Defining functions\r\n```vim\r\n   fun! Foo()\r\n   \" function body\r\n   endfun\r\n\r\n   function Foo()\r\n   \" function body\r\n   endfunction\r\n```\r\n\r\nCreate functions within the command window by putting each statement on a new line. i.e.\r\n```vim\r\n   :fun! Foo() [<CR>]\r\n   :  second line\r\n   : . . . . . \r\n```\r\n\r\nExecute them from the commandline window:\r\n```vim\r\n   :call Foo()\r\n```\r\nVariables have several possible scopes:\r\n`l` (local to function), `s` (local to individual scripts/files), `g` (global), `a` (a function parameter). \r\n\r\n`v` is a global like `g`, but has been predefined by vim. These cannot be defined by the user.\r\n\r\n`b` (local to current buffer), `w` (local to the current winow) and `t` (local to current tab)  are less often used.\r\n\r\nView defined variables:\r\n```vim\r\n   :let g:  \"or v:, b:, etcl\r\n```\r\nBy the way, we can use `\"` for comments\r\n\r\nView register contents:\r\n```vim\r\n   :reg\r\n```\r\n\r\nVariables are defined using let, e.g.:\r\n```vim\r\n let l:bar = \"red\"\r\n```\r\nVariables defined or accessed within a function are by default in the local scope. Prepending with `g:` allows access to global variables.\r\n\r\n\r\nArrays are much like python lists. They are type-agnostic and can be sliced.\r\n```vim\r\n   :let l:a = [1, 2, 'foo', 'bar']\r\n   :echo a[2:-1]` \"prints ['foo', 'bar']\r\n```\r\nStrings can also be sliced withe same syntax.\r\n\r\nString concatenation is php style:\r\n```vim\r\nlet g:pair = 'eight' . 'eight'\r\n```\r\nDirectly access the command line:\r\n```vim\r\n   :!echo -e \"bash\\nis\\nfun\" | cat > bar.txt \r\n```\r\nRead files into the buffer:\r\n```vim\r\n   :r bar.txt\r\n```\r\nProduces:\r\n```\r\nbash\r\nis\r\nfun\r\n```\r\nUnder your cursor.\r\n\r\nRead command outputs into the buffer:\r\n```vim\r\n   :r !curl -s icanhazip.com\r\n```\r\n\r\nIf your distribution of vim is compiled with python included (and it usually is) you can also access a python interpreter during your editing session.\r\n```python\r\n   :py print \"ni!\"\r\n```\r\nYou can access vim from the internal python interpreter.\r\n```python\r\n   :py import vim\r\n   :py vim.current.buffer[0] = 'Just answer the five (three!) questions'\r\n``` \r\nYou can go crazy with it if you like . . . \r\n```python\r\n   :py import requests, lxml.etree\r\n   :root = lxml.etree.HTML(requests.get('https://twitter.com/montypython').text)\r\n   :redir @i| exe ':silent py for t in  root.xpath(\"//p[contains(@class, \\\"ProfileTweet-text\\\")]/text()\"): print t.encode(\"utf8\")' | redir END | $put i\r\n```\r\nHere, `:redir` redirects output of the commands between `:redir` and `:redir END` (which would usually be printed in the command window) to some register. Vim has 26+ register (all alphabetical letters and additional reserved registers). `@i` accesses the value at register `i`, telling vim to pipe output there. `|` stands in place of `<CR>` to separate commands. `exe` executes the given command as if it were in the command. We can use it when we need to make a command out of concatenating strings. In this case, it lets us wrap the python code in '' so that python does not try to interpret the next `|`. `silent` tells vim not to echo the result of the command in the command window. `redir END` will populate our register `i` -- it won't get updated until the redirect is finished. Finally, we execute `put i`, which inserts the contents of register `i` after the cursor's current line. The `$` (which generally indecates \"last\") tells put to instead append to the last line of the buffer.\r\n\r\n\r\nThere are some useful global variables\r\n```vim\r\nv:statusmsg    \"usually holds the last item shown in the command window      \r\nv:warningmsg   e.g. W10: Warning: Changing a readonly file\r\nv:errmsg       e.g. E488: Trailing characters: put v:errmsg\r\n```\r\n\r\nUseful Motions (normal mode)\r\n```vim\r\ncommand    goes to\r\n`f<char>` next instance of <char>\r\n`)`       end of setnece\r\n`%`       matching parens/brace\r\n`$`       end of line\r\n`G`       end of file\r\n`}`       next paragraph\r\n```\r\nAdditionally, we have `visual` mode. A quick preview of that:  \r\n```vim\r\n<C-v>  \"To select columns. Any change propagates to all columns.\r\n   :vs [filename] \"split vertical window\r\n   :split [filename] \"split horizontally\r\n```\r\n`<C-w>` Is the window command suffix, so `<C-w> h` moves to the left widnow, `<C-w> l` to the right, `<C-w> k` moves to the upper window and `<C-w> j` moves to the lower one. I have the following mapping which forces this to work straight out of insert mode:\r\n```vim\r\n   :inoremap <C-w> <Esc> <C-w>\r\n```\r\n`<Esc>` exits to nromal mode. So does `<C-[>`; we can map the tab key to do it as well:\r\n```vim\r\n   :imap <tab> <Esc>\r\n```\r\nSo what can we do with all this? Well, we have lots of useful variables, lots of registers, and marks, and even [ communication protocol for controlling external processes] (http://vimdoc.sourceforge.net/htmldoc/netbeans.html). My next post will be about the project that most of this study has been devoted to. For now, I'll go over a few of my personal settings and one trick that is a bit obscure but extremely powerful.\r\n```vim\r\n   :noremap <C-d> :call search('def\\s\\s*(' . expand('<cword>')) <CR>\r\n```\r\n\r\nThe `search` function takes a string (remember that `.` performs string concatenation), searches the buffer for the regular expression, and moves the cursor to the the line of the found string. `search` returns the line of the found match, or `0` if no match was found (vim counts its buffer line from `1`). `<cword>` is an \"Ex special character\" (try `:h cmdline-special`). The `expand` function returns the special meaning of `<cword>`, which happens to be the current word under the cursor. So if the word under my cursor is \"print_lines\", search will be called on `def\\s+print_line(`. So this obscure little function will take you to the function definiton of whatever function you're currently hovering over. IF it's in the file. But what if it's not? Let's try a function. \r\n\r\n```vim\r\nfun! DefSearch()\r\n  let l:regex = 'def\\s\\s*(' . expand('<cword>')\r\n  if search(regex) == 0   \" search failed\r\n    silent 'grep -E \"'  . regex . '\" *.py'\r\n  endif\r\nendfun\r\n```    \r\nVimL's functions execute their code as if from the command-line (in vim, as if you prepended them with `:`). So `silent` `executes` the following command without echoing in the command window. It then execute's vim's built-in grep (which is a wrapper around bash's grep). grep's `E` allows you to use quote-wrapped regular expressions; -r forces a recursive search, if you like it. `*.py` will match any python files. Let's map it!\r\nFood()\r\n```vim\r\n   :noremap <C-d> :call DefSearch() <CR>\r\n```\r\nBut it's only useful if we're editing or reading a python file . . . we probably don't want to use it otherwise. So in the `.vimrc` file, we add:\r\n```vim\r\nau BufREadPost *.py :noremap <C-d> :call DefSearch() <CR>\r\n```\r\nTesting all this can be a bit of a drag, but as we are editing a vim script (or our .vimrc file) we can immmediately run it (and gain access to its globally-declared variables and functions) by calling `:source`. We can take advantage of anther \"cmd-line-special\" `%`, which in the command-line has the value of the current buffer name.\r\n```vim\r\n   :source %\r\n```\r\nOkay, one last trick. This one is real nifty. Info on it is in vim's extensive in-house documentation--just try `:h g@`. This trick allows you to capture user motions and reference them within a function. We do this by setting an 'operatorfunc' option. The result is a custom operator. Given a function Foo:\r\n\r\n```vim\r\n   :nmap <silent> <F4> :set opfunc=Echo<CR>g@\r\n   :vmap <silent> <F4> :<C-U>call Echo(visualmode(), 1)<CR>\r\n```\r\nNote: `:vmap` is the equivalent of `:nmap` for visual mode. The function defition:\r\n\r\n```vim\r\n\" uses [/] marks along with visual mode to yank a custom selection of text.\r\nfun! Echo(type, ...)\r\n  \"backticks=' (goto mark), have to avoid out-quoting string\r\n  \"clear the @q register for use in this function.\r\n  \"@q is the reserved phonim register.\r\n  let @q=\"\"\r\n  \" see :h g@ for more info and how to save and restore a register, which\r\n  \" would allow us to use 'q' only temporarily and then restore it \r\n  if a:0  \" Invoked from Visual mode, use '< and '> marks.\r\n    silent exe \"normal! `<\" . a:type . '`>\"qy'\r\n  elseif a:type == 'line'\r\n    silent exe 'normal! `[V`]\"qy'\r\n  elseif a:type == 'block' \" column ('block') selection. \r\n    silent exe 'normal! `[\\<C-V>`]\"qy'\r\n  \"v -> visual mode but stay in-line\r\n  else \" Stay in-line\r\n    silent exe 'normal! `[v`]\"qy'  \r\n  endif\r\n  echo @q\r\nendfun\r\n```\r\n\r\nThis function echos into the command-window any text that the user selects. It saves the user's selection in the `q` register (could be any letter). It is possible to store and restore this register so as not to lose its original contents.  Now `:normal` executes normal-mode commands, and will use any mappings that we defined by `nmap`. `:normal!` overrides this use of mapping.  The `opfunc` works by setting `[` and `]` marks to the beginning and end of the user motiton (i.e. to the next whitespace if it is `W` or the next like if it is `j`). The `Echo` function simply yanks the text between these two marks and stores them in the `q` register. We can then do whatever we like with the text, in this case echo it. The if statements gaurantee that the selection will work the same in visual and normal mode (`v` is for inline visual selection; `V` is for column or \"block\" selection). \r\n\r\nIn my next post I'll talk about an interesting application of this last technique--and VimL in general, and the reasoning behind all this research.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}